#### 哈希表
主要是应用于对find 操作效率很敏感的场景，它可以实现CRUD o(1)的复杂度，但是它要解决冲突问题，如果hash函数不够优秀，冲突数据过多，则会退化成链表或者树（取决于其使用的存储结构），它的存储结构是连续存储的数组，因为它的核心理念是下标重计算（通过hash函数），如果是链表结构，是无法通过下标来实现随机访问的。在c++中，哈希表的主要应用是unordered_map，它和map的区别是底层存储结构一个是hash表，一个是红黑树，所以map存储是有序的，unordered_map是无序的，但是它的插入和查找效率更高，所以对于堆数据有序没有要求的场景，可以用undered_map。

#### map ，set
这类数据结构主要应用与快速查找（log(n))，例如map可以根据key获取val，set可以判断是否在等，如果用vector，array，linklist之类的结构，只能遍历才能找到对应的值。所以实际开发中，map是使用频率最高的数据结构。
c++中map也是红黑树存储，所以CRUD 可以log(n)的复杂度，基于其特性，所有key的存储都是有序的。

#### 树
树从逻辑上可以理解成含有多个next的链表，我们用得最多的是排序树，其中尤其以二叉的为多，它拥有log(n)的CRUD 时间复杂度。解树的问题，最重要的是要理解递归思想，如果不允许用递归，可以考虑使用栈来模拟递归。

树的深度遍历DST，主要分前序，中序，后序，它是根据root节点所在的位置来决定的，如果不用四行递归来实现的话，就需要自己维护一==个栈==，来实现。

树的广度遍历BST，即分层遍历，不能用栈，得用==队列==，因为它是符合先进先出特性的，一开始把root压入队列，然后循环pop队列，pop时，把儿子压入队列，直到整个队列为空。


#### 堆
堆是一种特殊的树，工程上一般用的最多的是有序树，无序的树应用不多，因为它不能发挥树最重要的特性，CRUD都是log(n)，而堆是树中最重要堆一种==非排序树==，它要求是==完全二叉树==，它主要用于解决的是取最大值(大顶堆)或者最小值(小顶堆)的问题。因为它是完全二叉树，核心特点是父亲节点始终大于或者小于所有的儿子，儿子本身的大小顺序无关，所以它通常可以用==数组==来存储（可以直接计算得出节点位置，通过数组的特性来实现下标随机访问）
堆又很多种，不过我们的算法学习中，讨论的一般是二叉堆，因为实现简单，取最大-小值可以实现O(1)，其他的操作是log(n)--因为要进行堆化来保证堆的结构特性。

堆的一个重要应用是 优先队列 priority_queue,实际开发中，可以用priority_queue来实现堆相关功能。

